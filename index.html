<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#0f0f1a">
<title>Faceballs</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#0f0f1a;display:flex;justify-content:center;align-items:center;height:100vh;overflow:hidden}
canvas{display:block;max-width:100vw;max-height:100vh;width:auto;height:auto;object-fit:contain;touch-action:none}
#announcer-modal{display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#1a1a2e;border:2px solid #2a80ff;border-radius:12px;padding:20px;z-index:100;width:340px;color:#fff;font-family:sans-serif}
#announcer-modal.open{display:block}
#announcer-modal h3{margin:0 0 14px;font-size:16px;text-align:center;color:#5ca0f0}
#announcer-modal label{display:block;font-size:12px;color:#888;margin:8px 0 3px}
#announcer-modal input[type="text"],#announcer-modal input[type="password"],#announcer-modal select{width:100%;padding:6px 8px;background:#0f0f1a;border:1px solid #444;border-radius:4px;color:#fff;font-size:13px;outline:none}
#announcer-modal input:focus,#announcer-modal select:focus{border-color:#2a80ff}
#announcer-modal .ann-provider-fields{margin-top:4px}
#announcer-modal .ann-row{display:flex;align-items:center;justify-content:space-between;margin:10px 0}
#announcer-modal .ann-row label{margin:0;flex:1}
#announcer-modal .ann-toggle{width:40px;height:22px;background:#444;border-radius:11px;position:relative;cursor:pointer;flex-shrink:0}
#announcer-modal .ann-toggle.on{background:#2a80ff}
#announcer-modal .ann-toggle::after{content:'';position:absolute;top:2px;left:2px;width:18px;height:18px;background:#fff;border-radius:50%;transition:left .15s}
#announcer-modal .ann-toggle.on::after{left:20px}
#announcer-modal .ann-vol{display:flex;align-items:center;gap:8px;margin:10px 0}
#announcer-modal .ann-vol input[type="range"]{flex:1;accent-color:#2a80ff}
#announcer-modal .ann-btns{display:flex;gap:8px;margin-top:14px}
#announcer-modal .ann-btns button{flex:1;padding:8px;border:none;border-radius:6px;font-size:14px;font-weight:bold;cursor:pointer}
#announcer-modal .ann-save{background:#2a80ff;color:#fff}
#announcer-modal .ann-cancel{background:#333;color:#aaa}
#announcer-overlay{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:99}
</style>
</head>
<body>
<canvas id="c"></canvas>
<input id="nameInput" type="text" maxlength="10" autocomplete="off" style="position:fixed;top:50%;left:50%;width:1px;height:1px;border:none;outline:none;opacity:0;font-size:16px">
<div id="announcer-overlay" onclick="document.getElementById('announcer-modal').classList.remove('open');this.style.display='none'"></div>
<div id="announcer-modal">
  <h3>AI Announcer</h3>
  <label>OpenAI API Key</label>
  <input type="password" id="ann-openai" placeholder="sk-...">
  <label>TTS Provider</label>
  <select id="ann-provider">
    <option value="elevenlabs">ElevenLabs</option>
    <option value="hume">Hume AI (Octave)</option>
  </select>
  <div class="ann-provider-fields" id="ann-fields-eleven">
    <label>ElevenLabs API Key</label>
    <input type="password" id="ann-eleven" placeholder="xi-...">
    <label>ElevenLabs Voice ID</label>
    <input type="text" id="ann-voice" placeholder="JBFqnCBsd6RMkjVDRZzb">
  </div>
  <div class="ann-provider-fields" id="ann-fields-hume" style="display:none">
    <label>Hume API Key</label>
    <input type="password" id="ann-hume" placeholder="...">
  </div>
  <div class="ann-row">
    <label>Enable Announcer</label>
    <div class="ann-toggle" id="ann-toggle"></div>
  </div>
  <div class="ann-vol">
    <label style="flex:none;margin:0">Volume</label>
    <input type="range" id="ann-volume" min="0" max="1" step="0.05" value="0.8">
  </div>
  <div class="ann-btns">
    <button class="ann-cancel" id="ann-cancel">Cancel</button>
    <button class="ann-save" id="ann-save">Save</button>
  </div>
</div>
<script type="module">
import PartySocket from 'https://esm.sh/partysocket';

const PARTYKIT_HOST = location.hostname === 'localhost'
  ? 'localhost:1999' : 'faceballs.ilmeri.partykit.dev';

const cvs = document.getElementById('c'), ctx = cvs.getContext('2d');
const W = 960, H = 640;
cvs.width = W; cvs.height = H;

// ===== Field =====
const FM = 60;
const FL = FM, FT = FM, FR = W - FM, FB = H - FM;
const FW = FR - FL, FH = FB - FT;
const FCX = (FL + FR) / 2, FCY = (FT + FB) / 2;

// ===== Goals =====
const GH = 160, GD = 34;
const GT = FCY - GH / 2, GB = FCY + GH / 2;

// ===== Physics (tunable at runtime) =====
let FRIC = 0.982, REST = 0.78;
const MIN_V = 0.15;
let MAX_POW = 16, POW_RATE = 20;
let ROT_SPD = 2.8;
let PR = 18, BR = 12;
const PMASS = 3, BMASS = 1;
const WIN_SCORE = 5;

const ST_ROT = 0, ST_AIM = 1;

const goalPosts = [
  { x: FL, y: GT, r: 5 }, { x: FL, y: GB, r: 5 },
  { x: FR, y: GT, r: 5 }, { x: FR, y: GB, r: 5 }
];

const TEAMS = [
  { name: 'BLUE', color: '#2a80ff' },
  { name: 'RED',  color: '#e04545' },
];
const COLORS  = ['#1b5eb5','#4da3e8','#c43030','#e87050'];
const CLIGHTS = ['#5ca0f0','#8ecaff','#ff6868','#ffaa80'];
const SLOT_TEAMS = [0, 0, 1, 1];
const FILL_ORDER = [0, 2, 1, 3];

// ===== Game State =====
let gameState = 'MENU'; // MENU, WAITING, PLAYING, GAME_OVER
let players = [], fb, lastToucher = null;
let teamScores = [0, 0];
let goalScoredBy = null, goalTimer = 0, winner = null;
const GOAL_PAUSE = 2.0;

// ===== Multiplayer State =====
let mySlot = -1;
let ws = null;
let slots = [null, null, null, null];
let roomCode = '';
let roomMode = '';
let codeInput = '';
let showCodeInput = false;
let myRematchVoted = false;
let rematchVoteCount = 0;
let rematchVoteTotal = 0;
let statusMsg = '';

// Player names
let myName = localStorage.getItem('faceballs-name') || '';
let playerNames = ['', '', '', ''];
let nameEditing = false;
const nameEl = document.getElementById('nameInput');
nameEl.value = myName;
nameEl.addEventListener('input', () => { myName = nameEl.value.replace(/[^a-zA-Z0-9 _\-]/g, '').slice(0, 10); nameEl.value = myName; });
nameEl.addEventListener('blur', () => { nameEditing = false; localStorage.setItem('faceballs-name', myName); });
nameEl.addEventListener('keydown', e => { if (e.key === 'Enter') { nameEl.blur(); } });

// Client prediction smoothing (own player + ball)
let smoothX = 0, smoothY = 0;
const SMOOTH_DECAY = 0.7;
let ballSmoothX = 0, ballSmoothY = 0;
const BALL_SMOOTH_DECAY = 0.6;

// Client interpolation buffer
let pendingState = null;
let interpFrom = null;
let interpTo = null;
let interpStart = 0;
const INTERP_MS = 3 * (1 / 60) * 1000; // ~50ms (server sends at 20Hz = every 3 ticks)

// Auto-rematch (quickplay)
let autoRematchTimer = 0;
const AUTO_REMATCH_DELAY = 3.0;

// Shoot mode (0 = classic auto-rotate, 1 = click-aim)
let myShootMode = 0;
let aimPos = null;
let lastAimSend = 0;
let mode2ShootTime = 0; // timestamp of last mode 2 shoot (grace period for server state)
const AIM_SEND_INTERVAL = 100; // ~10Hz throttle for aim updates
const MODE2_SHOOT_GRACE = 200; // ms: ignore server state/power after mode 2 shoot
const MODE_BTN = { x: 10, y: 8, w: 28, h: 24, gap: 4 };

// Tuning panel
let tuningOpen = false;
let showAimLine = false;
const TUNE_BTN = { x: W - 36, y: 8, w: 28, h: 24 };
const TUNE_PANEL = { x: W - 220, y: 36, w: 212, rowH: 28, pad: 8 };
const TUNABLES = [
  { key: 'MAX_POW',  label: 'Power',    min: 4,    max: 40,    step: 2,     dp: 0 },
  { key: 'POW_RATE', label: 'Charge',   min: 5,    max: 60,    step: 5,     dp: 0 },
  { key: 'FRIC',     label: 'Friction', min: 0.95, max: 0.999, step: 0.003, dp: 3 },
  { key: 'ROT_SPD',  label: 'Rotation', min: 0.5,  max: 8,     step: 0.3,   dp: 1 },
  { key: 'REST',     label: 'Bounce',   min: 0.3,  max: 1.2,   step: 0.05,  dp: 2 },
  { key: 'PR',       label: 'Player Size', min: 8, max: 36,    step: 2,     dp: 0 },
  { key: 'BR',       label: 'Ball Size',   min: 6, max: 24,    step: 2,     dp: 0 },
];
function getParam(k) {
  if (k === 'MAX_POW') return MAX_POW; if (k === 'POW_RATE') return POW_RATE;
  if (k === 'FRIC') return FRIC; if (k === 'ROT_SPD') return ROT_SPD; if (k === 'REST') return REST;
  if (k === 'PR') return PR; if (k === 'BR') return BR;
}
function setParam(k, v) {
  if (k === 'MAX_POW') MAX_POW = v; else if (k === 'POW_RATE') POW_RATE = v;
  else if (k === 'FRIC') FRIC = v; else if (k === 'ROT_SPD') ROT_SPD = v; else if (k === 'REST') REST = v;
  else if (k === 'PR') { PR = v; players.forEach(p => p.r = PR); }
  else if (k === 'BR') { BR = v; if (fb) fb.r = BR; }
}
function sendParams() {
  if (ws) ws.send(JSON.stringify({ type: 'params', MAX_POW, POW_RATE, FRIC, ROT_SPD, REST, PR, BR }));
}

// ===== Announcer =====
let announcerEnabled = false;
let announcerKeys = { openai: '', elevenlabs: '', voiceId: 'JBFqnCBsd6RMkjVDRZzb', hume: '', ttsProvider: 'elevenlabs' };
let announcerQueue = [];
let announcerBusy = false;
let announcerVolume = 0.8;
let subtitleText = '';
let subtitleTimer = 0;
let currentAnnounceAudio = null;

// Load announcer config from localStorage
try {
  const saved = JSON.parse(localStorage.getItem('faceballs-announcer') || '{}');
  if (saved.openai) announcerKeys.openai = saved.openai;
  if (saved.elevenlabs) announcerKeys.elevenlabs = saved.elevenlabs;
  if (saved.voiceId) announcerKeys.voiceId = saved.voiceId;
  if (saved.hume) announcerKeys.hume = saved.hume;
  if (saved.ttsProvider) announcerKeys.ttsProvider = saved.ttsProvider;
  if (saved.enabled !== undefined) announcerEnabled = saved.enabled;
  if (saved.volume !== undefined) announcerVolume = saved.volume;
} catch {}

function isAnnouncerHost() {
  if (!announcerEnabled || !announcerKeys.openai) return false;
  if (announcerKeys.ttsProvider === 'hume') return !!announcerKeys.hume;
  return !!announcerKeys.elevenlabs;
}

// Announcer modal UI
const annModal = document.getElementById('announcer-modal');
const annOverlay = document.getElementById('announcer-overlay');
const annToggle = document.getElementById('ann-toggle');
const annOpenai = document.getElementById('ann-openai');
const annEleven = document.getElementById('ann-eleven');
const annVoice = document.getElementById('ann-voice');
const annHume = document.getElementById('ann-hume');
const annProvider = document.getElementById('ann-provider');
const annVolumeEl = document.getElementById('ann-volume');
const annFieldsEleven = document.getElementById('ann-fields-eleven');
const annFieldsHume = document.getElementById('ann-fields-hume');

function updateProviderFields() {
  const isHume = annProvider.value === 'hume';
  annFieldsEleven.style.display = isHume ? 'none' : 'block';
  annFieldsHume.style.display = isHume ? 'block' : 'none';
}
annProvider.addEventListener('change', updateProviderFields);

function openAnnouncerModal() {
  annOpenai.value = announcerKeys.openai;
  annEleven.value = announcerKeys.elevenlabs;
  annVoice.value = announcerKeys.voiceId;
  annHume.value = announcerKeys.hume;
  annProvider.value = announcerKeys.ttsProvider;
  annVolumeEl.value = announcerVolume;
  annToggle.classList.toggle('on', announcerEnabled);
  updateProviderFields();
  annModal.classList.add('open');
  annOverlay.style.display = 'block';
}

function closeAnnouncerModal() {
  annModal.classList.remove('open');
  annOverlay.style.display = 'none';
}

annToggle.addEventListener('click', () => annToggle.classList.toggle('on'));
document.getElementById('ann-cancel').addEventListener('click', closeAnnouncerModal);
document.getElementById('ann-save').addEventListener('click', () => {
  announcerKeys.openai = annOpenai.value.trim();
  announcerKeys.elevenlabs = annEleven.value.trim();
  announcerKeys.voiceId = annVoice.value.trim() || 'JBFqnCBsd6RMkjVDRZzb';
  announcerKeys.hume = annHume.value.trim();
  announcerKeys.ttsProvider = annProvider.value;
  announcerEnabled = annToggle.classList.contains('on');
  announcerVolume = parseFloat(annVolumeEl.value);
  localStorage.setItem('faceballs-announcer', JSON.stringify({
    openai: announcerKeys.openai, elevenlabs: announcerKeys.elevenlabs,
    voiceId: announcerKeys.voiceId, hume: announcerKeys.hume,
    ttsProvider: announcerKeys.ttsProvider, enabled: announcerEnabled, volume: announcerVolume
  }));
  closeAnnouncerModal();
});

// Stop modal key events from reaching game
annModal.addEventListener('keydown', e => e.stopPropagation());
annModal.addEventListener('keyup', e => e.stopPropagation());

// Build LLM prompt for an event
function buildAnnouncerPrompt(ev) {
  const teamNames = ['Blue', 'Red'];
  let userMsg = '';
  switch (ev.event) {
    case 'gameStart': {
      const blue = [ev.names[0], ev.names[1]].filter(Boolean).join(' & ') || 'Blue team';
      const red = [ev.names[2], ev.names[3]].filter(Boolean).join(' & ') || 'Red team';
      userMsg = `New game starting! Blue team: ${blue}. Red team: ${red}. First to 5 wins.`;
      break;
    }
    case 'goal': {
      const who = ev.scorer || teamNames[ev.scorerTeam];
      userMsg = `GOAL! ${who} scores for ${teamNames[ev.scorerTeam]}! Score is now Blue ${ev.scores[0]} - ${ev.scores[1]} Red.`;
      if (ev.quickGoal) userMsg += ' This was a lightning-fast goal, barely seconds after kickoff!';
      if (ev.isMatchPoint) userMsg += ` ${teamNames[ev.scorerTeam]} is now just ONE goal away from winning!`;
      if (ev.isGameOver) userMsg += ' This is the WINNING GOAL! Game over!';
      break;
    }
    case 'gameOver': {
      userMsg = `GAME OVER! ${teamNames[ev.winnerTeam]} team wins! Final score: Blue ${ev.scores[0]} - ${ev.scores[1]} Red.`;
      const mvp = ev.playerGoals ? ev.playerGoals.indexOf(Math.max(...ev.playerGoals)) : -1;
      if (mvp >= 0 && ev.names[mvp] && ev.playerGoals[mvp] > 0) {
        userMsg += ` MVP: ${ev.names[mvp]} with ${ev.playerGoals[mvp]} goals!`;
      }
      break;
    }
    case 'save': {
      const who = ev.saver || teamNames[ev.saverTeam];
      userMsg = `WHAT A SAVE by ${who}! The ball was heading straight for the ${teamNames[ev.saverTeam]} goal but ${who} got in the way just in time! Score: Blue ${ev.scores[0]} - ${ev.scores[1]} Red.`;
      break;
    }
    case 'nearMiss': {
      userMsg = `OFF THE POST! The ball smashes into the goalpost and bounces away! So close to a goal! Score: Blue ${ev.scores[0]} - ${ev.scores[1]} Red.`;
      break;
    }
    case 'commentary': {
      const activePlayers = ev.names ? ev.names.filter(Boolean) : [];
      if (ev.scores[0] === ev.scores[1]) {
        userMsg = `It's all square at ${ev.scores[0]}-${ev.scores[1]}! Give some dramatic mid-match color commentary about how tense this is.`;
      } else {
        const leading = ev.scores[0] > ev.scores[1] ? 'Blue' : 'Red';
        const trailing = ev.scores[0] > ev.scores[1] ? 'Red' : 'Blue';
        userMsg = `${leading} leads ${ev.scores[0]}-${ev.scores[1]}. Give dramatic mid-match color commentary. Can ${trailing} mount a comeback?`;
      }
      if (activePlayers.length > 0) userMsg += ` Players on the field: ${activePlayers.join(', ')}.`;
      break;
    }
    default: return null;
  }
  return userMsg;
}

const HUME_ACTING = {
  goal: [
    'screaming with excitement, over-the-top, barely able to contain yourself',
    'absolutely losing your mind, voice cracking from intensity',
    'operatic triumph, singing the words with joy',
    'hushed disbelief building to explosive screaming',
  ],
  save: [
    'shocked and amazed, gasping, disbelief',
    'breathless, stunned, whispering in awe',
    'furious and impressed at the same time, growling respect',
  ],
  nearMiss: [
    'dramatic tension, sharp intake of breath, on the edge of your seat',
    'agonized groan, clutching your head in despair',
    'nervous laughter, barely surviving the suspense',
  ],
  gameStart: [
    'hyped up, energetic, welcoming a roaring crowd',
    'booming authority, commanding the arena like a wrestling announcer',
    'conspiratorial whisper building to a shout',
  ],
  gameOver: [
    'dramatic finale, epic conclusion, building to a crescendo',
    'tearful, overwhelmed with emotion, voice breaking',
    'smug satisfaction, like you predicted it all along',
  ],
  commentary: [
    'smooth confident broadcaster, classic sports commentator',
    'paranoid whisper, like sharing a secret conspiracy',
    'wistful nostalgia, reminiscing about the old days',
    'barely suppressed giggles, finding everything hilarious',
  ],
};
function getHumeActing(event) {
  const options = HUME_ACTING[event] || ['enthusiastic sports announcer'];
  return options[Math.floor(Math.random() * options.length)];
}

async function blobToBase64(blob) {
  const reader = new FileReader();
  return new Promise(resolve => {
    reader.onloadend = () => resolve(reader.result.split(',')[1]);
    reader.readAsDataURL(blob);
  });
}

const ANNOUNCER_PERSONAS = [
  'You are a completely unhinged WWE-style wrestling announcer calling a Faceballs match. Treat every play like a championship moment. Scream. Use wrestling metaphors. "BAH GAWD!"',
  'You are David Attenborough narrating a Faceballs match like a nature documentary. Treat the players as fascinating creatures in their natural habitat. Hushed, reverent wonder.',
  'You are a medieval herald announcing a Faceballs match as if it were a grand jousting tournament. Use "ye", "hark", "forsooth". Speak of honor and glory.',
  'You are a telenovela narrator for a Faceballs match. Everything is dramatic betrayal, forbidden love, and destiny. Passion drips from every word.',
  'You are a hyperactive anime play-by-play announcer. Reference power levels, ultimate moves, and dramatic transformations. "IMPOSSIBLE! He\'s broken through his limits!"',
  'You are a noir detective narrating a Faceballs match like a 1940s crime story. Dark, moody, world-weary. "The ball rolled into the net like a bad memory."',
  'You are a Silicon Valley tech bro live-commentating Faceballs. Everything is "disrupting the space", "10x play", "paradigm shift". Pitch the goals like startup ideas.',
  'You are a dramatic opera announcer narrating Faceballs. Everything is a grand tragedy or triumph. Reference acts, arias, and the audience weeping.',
  'You are a conspiracy theorist calling a Faceballs match. Every goal was planned by the Illuminati. The ball trajectory proves the Earth is flat. Connect dots that don\'t exist.',
  'You are Gordon Ramsay commentating Faceballs. Furious. Disappointed. Occasionally impressed. "That defense was RAW! Absolutely DONKEY behavior!"',
  'You are a grandma watching her first Faceballs match. Confused but supportive. Mix up the rules. Offer snacks. "Oh my, is that a touchdown? Good for him!"',
  'You are a pirate captain narrating a Faceballs match. Everything is about treasure, the seven seas, and scurvy dogs. "ARRR, that goal be worth its weight in doubloons!"',
];

const STYLE_SPICE = [
  'Make a wild comparison to something completely unrelated.',
  'Invent a ridiculous statistic.',
  'Break the fourth wall briefly.',
  'Reference an imaginary rivalry or backstory between players.',
  'Use an extended metaphor from cooking or food.',
  'Pretend you\'re getting emotional and tearing up.',
  'Suddenly question reality for a moment.',
  'Make up a dramatic nickname for a player on the spot.',
  'Reference the weather or atmosphere in the imaginary stadium.',
  'Briefly pretend the game has cosmic or supernatural significance.',
  'Work in a pun or wordplay.',
  'Narrate as if the replay is in slow motion.',
];

function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

function buildSystemPrompt() {
  const persona = pick(ANNOUNCER_PERSONAS);
  const spice = pick(STYLE_SPICE);
  return `${persona}\n\nThe game is Faceballs — a chaotic multiplayer football game where players are bouncing balls that shoot themselves around the field. Give 1-2 short punchy sentences. Reference player names when available. Never use hashtags or emojis.\n\nStyle twist for this line: ${spice}`;
}

async function generateAnnouncement(ev) {
  const userMsg = buildAnnouncerPrompt(ev);
  if (!userMsg) return;

  try {
    // Call OpenAI for commentary text
    const chatRes = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + announcerKeys.openai },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        temperature: 1.2,
        max_tokens: 80,
        messages: [
          { role: 'system', content: buildSystemPrompt() },
          { role: 'user', content: userMsg }
        ]
      })
    });
    if (!chatRes.ok) { console.warn('Announcer OpenAI error:', chatRes.status); return; }
    const chatData = await chatRes.json();
    const text = chatData.choices?.[0]?.message?.content?.trim();
    if (!text) return;

    // Call TTS provider
    let base64;
    if (announcerKeys.ttsProvider === 'hume') {
      const ttsRes = await fetch('https://api.hume.ai/v0/tts/file', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-Hume-Api-Key': announcerKeys.hume },
        body: JSON.stringify({
          utterances: [{
            text,
            description: getHumeActing(ev.event),
            speed: ev.event === 'goal' ? 1.2 : 1.0
          }],
          format: { type: 'mp3' }
        })
      });
      if (!ttsRes.ok) { console.warn('Announcer Hume error:', ttsRes.status); return; }
      base64 = await blobToBase64(await ttsRes.blob());
    } else {
      const ttsRes = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${announcerKeys.voiceId}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'xi-api-key': announcerKeys.elevenlabs },
        body: JSON.stringify({
          text,
          model_id: 'eleven_turbo_v2_5',
          voice_settings: { stability: 0.4, similarity_boost: 0.8 }
        })
      });
      if (!ttsRes.ok) { console.warn('Announcer ElevenLabs error:', ttsRes.status); return; }
      base64 = await blobToBase64(await ttsRes.blob());
    }

    // Send to server for relay to all clients
    if (ws) ws.send(JSON.stringify({ type: 'announce', audio: base64, text }));
  } catch (err) {
    console.warn('Announcer error:', err);
  }
}

async function processAnnouncerQueue() {
  if (announcerBusy) return;
  if (announcerQueue.length === 0) return;
  // Drop stale events (keep max 2)
  while (announcerQueue.length > 2) announcerQueue.shift();
  const ev = announcerQueue.shift();
  announcerBusy = true;
  try {
    await generateAnnouncement(ev);
  } finally {
    announcerBusy = false;
    if (announcerQueue.length > 0) processAnnouncerQueue();
  }
}

function handleAnnouncerEvent(ev) {
  if (!isAnnouncerHost()) return;
  announcerQueue.push(ev);
  processAnnouncerQueue();
}

function playAnnouncement(audio64, text) {
  // Stop any currently playing announcement
  if (currentAnnounceAudio) {
    currentAnnounceAudio.pause();
    currentAnnounceAudio = null;
  }
  const audio = new Audio('data:audio/mpeg;base64,' + audio64);
  audio.volume = announcerVolume;
  currentAnnounceAudio = audio;
  subtitleText = text;
  subtitleTimer = 10; // will be overridden by audio end
  audio.play().catch(() => {});
  audio.addEventListener('ended', () => {
    currentAnnounceAudio = null;
    // Keep subtitle for 1.5s after audio ends
    subtitleTimer = 1.5;
  });
  audio.addEventListener('error', () => {
    currentAnnounceAudio = null;
    subtitleTimer = 3;
  });
}

// Announcer button position (next to tuning gear)
const ANN_BTN = { x: W - 70, y: 8, w: 28, h: 24 };

function drawAnnouncerButton() {
  if (gameState !== 'PLAYING' && gameState !== 'GAME_OVER') return;
  const { x, y, w, h } = ANN_BTN;
  ctx.fillStyle = isAnnouncerHost() ? '#2a80ff' : 'rgba(255,255,255,0.1)';
  ctx.fillRect(x, y, w, h);
  ctx.strokeStyle = isAnnouncerHost() ? '#5ca0f0' : '#555';
  ctx.lineWidth = 1;
  ctx.strokeRect(x, y, w, h);
  // Mic icon (simple drawn shape)
  ctx.fillStyle = isAnnouncerHost() ? '#fff' : '#888';
  ctx.font = '15px sans-serif';
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText('AI', x + w / 2, y + h / 2);
}

function handleAnnouncerButtonClick(pos) {
  if (gameState !== 'PLAYING' && gameState !== 'GAME_OVER') return false;
  if (inRect(pos, ANN_BTN.x, ANN_BTN.y, ANN_BTN.w, ANN_BTN.h)) {
    openAnnouncerModal();
    return true;
  }
  return false;
}

function drawSubtitle() {
  if (!subtitleText || subtitleTimer <= 0) return;
  const barH = 50;
  const barY = H - barH;
  const alpha = Math.min(subtitleTimer, 1);
  ctx.save();
  ctx.globalAlpha = alpha * 0.75;
  ctx.fillStyle = '#000';
  ctx.fillRect(0, barY, W, barH);
  ctx.globalAlpha = alpha;
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 16px sans-serif';
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  // Wrap text if too long
  const maxW = W - 40;
  const words = subtitleText.split(' ');
  let lines = [], line = '';
  for (const word of words) {
    const test = line ? line + ' ' + word : word;
    if (ctx.measureText(test).width > maxW) {
      lines.push(line);
      line = word;
    } else {
      line = test;
    }
  }
  if (line) lines.push(line);
  if (lines.length > 2) lines = lines.slice(0, 2);
  const lineH = 20;
  const startY = barY + barH / 2 - (lines.length - 1) * lineH / 2;
  for (let i = 0; i < lines.length; i++) {
    ctx.fillText(lines[i], W / 2, startY + i * lineH);
  }
  ctx.restore();
}

// ===== Player =====
class Player {
  constructor(sx, sy, color, light, idx, team) {
    this.sx = sx; this.sy = sy;
    this.x = sx; this.y = sy; this.vx = 0; this.vy = 0;
    this.r = PR; this.mass = PMASS;
    this.color = color; this.light = light;
    this.idx = idx; this.team = team;
    this.label = String(idx + 1);
    this.angle = Math.random() * Math.PI * 2;
    this.power = 0; this.state = ST_ROT;
    this.occupied = false;
  }
  reset() {
    this.x = this.sx; this.y = this.sy; this.vx = 0; this.vy = 0;
    this.angle = Math.random() * Math.PI * 2;
    this.power = 0; this.state = ST_ROT;
  }
  update(dt) {
    if (this.occupied) {
      if (this.state === ST_ROT) this.angle += ROT_SPD * dt;
      else if (this.state === ST_AIM) this.power = Math.min(this.power + POW_RATE * dt, MAX_POW);
    }
    this.x += this.vx; this.y += this.vy;
    this.vx *= FRIC; this.vy *= FRIC;
    if (Math.abs(this.vx) < MIN_V && Math.abs(this.vy) < MIN_V) { this.vx = 0; this.vy = 0; }
  }
  shoot() {
    const p = Math.max(this.power, 1);
    this.vx += Math.cos(this.angle) * p;
    this.vy += Math.sin(this.angle) * p;
    this.state = ST_ROT; this.power = 0;
  }
}

// ===== Football =====
function makeFb() { return { x: FCX, y: FCY, vx: 0, vy: 0, r: BR, mass: BMASS }; }
function updateFb() {
  fb.x += fb.vx; fb.y += fb.vy;
  fb.vx *= FRIC; fb.vy *= FRIC;
  if (Math.abs(fb.vx) < MIN_V && Math.abs(fb.vy) < MIN_V) { fb.vx = 0; fb.vy = 0; }
}

// ===== Init =====
function initGame() {
  const I = 60;
  players = [
    new Player(FL + I, FT + I, COLORS[0], CLIGHTS[0], 0, 0),
    new Player(FL + I, FB - I, COLORS[1], CLIGHTS[1], 1, 0),
    new Player(FR - I, FT + I, COLORS[2], CLIGHTS[2], 2, 1),
    new Player(FR - I, FB - I, COLORS[3], CLIGHTS[3], 3, 1),
  ];
  fb = makeFb();
  lastToucher = null; teamScores = [0, 0];
  goalScoredBy = null; goalTimer = 0; winner = null;
  for (let i = 0; i < 4; i++) players[i].occupied = slots[i] !== null;
}

function resetField() {
  for (const p of players) p.reset();
  fb = makeFb();
  lastToucher = null; goalScoredBy = null; goalTimer = 0;
}

// ===== Physics =====
function circleCol(a, b, am, bm) {
  const dx = b.x - a.x, dy = b.y - a.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const minD = a.r + b.r;
  if (dist >= minD || dist === 0) return false;
  const nx = dx / dist, ny = dy / dist;
  const overlap = minD - dist;
  const inv = 1 / am + 1 / bm;
  a.x -= overlap * (1 / am) / inv * nx;
  a.y -= overlap * (1 / am) / inv * ny;
  b.x += overlap * (1 / bm) / inv * nx;
  b.y += overlap * (1 / bm) / inv * ny;
  const dvx = a.vx - b.vx, dvy = a.vy - b.vy;
  const dvn = dvx * nx + dvy * ny;
  if (dvn <= 0) return true;
  const j = (1 + REST) * dvn / inv;
  a.vx -= j * nx / am; a.vy -= j * ny / am;
  b.vx += j * nx / bm; b.vy += j * ny / bm;
  return true;
}

function postCol(ball) {
  for (const post of goalPosts) {
    const dx = ball.x - post.x, dy = ball.y - post.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const minD = ball.r + post.r;
    if (dist < minD && dist > 0) {
      const nx = dx / dist, ny = dy / dist;
      ball.x = post.x + nx * minD; ball.y = post.y + ny * minD;
      const dot = ball.vx * nx + ball.vy * ny;
      if (dot < 0) { ball.vx -= (1 + REST) * dot * nx; ball.vy -= (1 + REST) * dot * ny; }
    }
  }
}

function wallBounce(b) {
  const r = b.r;
  if (b.y - r < FT) { b.y = FT + r; if (b.vy < 0) b.vy *= -REST; }
  if (b.y + r > FB) { b.y = FB - r; if (b.vy > 0) b.vy *= -REST; }
  const inGoalY = b.y >= GT && b.y <= GB;
  if (b.x - r < FL) {
    if (inGoalY) {
      if (b.x - r < FL - GD) { b.x = FL - GD + r; if (b.vx < 0) b.vx *= -REST; }
    } else { b.x = FL + r; if (b.vx < 0) b.vx *= -REST; }
  }
  if (b.x < FL && b.x > FL - GD - r) {
    if (b.y - r < GT) { b.y = GT + r; if (b.vy < 0) b.vy *= -REST; }
    if (b.y + r > GB) { b.y = GB - r; if (b.vy > 0) b.vy *= -REST; }
  }
  if (b.x + r > FR) {
    if (inGoalY) {
      if (b.x + r > FR + GD) { b.x = FR + GD - r; if (b.vx > 0) b.vx *= -REST; }
    } else { b.x = FR - r; if (b.vx > 0) b.vx *= -REST; }
  }
  if (b.x > FR && b.x < FR + GD + r) {
    if (b.y - r < GT) { b.y = GT + r; if (b.vy < 0) b.vy *= -REST; }
    if (b.y + r > GB) { b.y = GB - r; if (b.vy > 0) b.vy *= -REST; }
  }
}

function checkGoal() {
  let scoringTeam = -1;
  if (fb.x < FL && fb.y > GT && fb.y < GB) scoringTeam = 1;
  if (fb.x > FR && fb.y > GT && fb.y < GB) scoringTeam = 0;
  if (scoringTeam >= 0) {
    teamScores[scoringTeam]++;
    const scorer = lastToucher ? (playerNames[lastToucher.idx] || '') : '';
    goalScoredBy = { team: scoringTeam, color: TEAMS[scoringTeam].color,
                     name: TEAMS[scoringTeam].name, scorer };
    goalTimer = GOAL_PAUSE;
    if (teamScores[scoringTeam] >= WIN_SCORE) winner = goalScoredBy;
  }
}

// ===== Canvas Helpers =====
function canvasPos(e) {
  const rect = cvs.getBoundingClientRect();
  const sx = W / rect.width, sy = H / rect.height;
  let cx, cy;
  if (e.touches && e.touches.length > 0) { cx = e.touches[0].clientX; cy = e.touches[0].clientY; }
  else if (e.changedTouches && e.changedTouches.length > 0) { cx = e.changedTouches[0].clientX; cy = e.changedTouches[0].clientY; }
  else { cx = e.clientX; cy = e.clientY; }
  return { x: (cx - rect.left) * sx, y: (cy - rect.top) * sy };
}

function inRect(pos, x, y, w, h) {
  return pos.x >= x && pos.x <= x + w && pos.y >= y && pos.y <= y + h;
}

function drawBtn(x, y, w, h, label, color = '#2a80ff', enabled = true) {
  ctx.globalAlpha = enabled ? 1 : 0.4;
  ctx.fillStyle = color;
  const r = 8;
  ctx.beginPath();
  ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.fill();
  ctx.fillStyle = '#fff'; ctx.font = 'bold 18px sans-serif';
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText(label, x + w / 2, y + h / 2);
  ctx.globalAlpha = 1;
}

// ===== UI: Menu Screen =====
const BTN_W = 240, BTN_H = 50;
const NAME_BOX = { x: FCX - 110, y: 228, w: 220, h: 34 };
const menuBtns = [
  { label: 'QUICK PLAY', y: 310, action: 'quick' },
  { label: 'CREATE PRIVATE', y: 380, action: 'create' },
  { label: 'JOIN PRIVATE', y: 450, action: 'join' },
];

function drawMenuScreen() {
  ctx.fillStyle = '#0f0f1a'; ctx.fillRect(0, 0, W, H);
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.font = 'bold 72px sans-serif';
  ctx.fillStyle = '#2a80ff'; ctx.fillText('FACE', FCX - 100, 140);
  ctx.fillStyle = '#e04545'; ctx.fillText('BALLS', FCX + 110, 140);
  ctx.font = '16px sans-serif'; ctx.fillStyle = '#666';
  ctx.fillText('Multiplayer Football', FCX, 190);

  // Name input
  ctx.font = '13px sans-serif'; ctx.fillStyle = '#888';
  ctx.fillText('YOUR NAME', FCX, NAME_BOX.y - 10);
  ctx.fillStyle = nameEditing ? '#1a1a3e' : '#1a1a2e';
  ctx.fillRect(NAME_BOX.x, NAME_BOX.y, NAME_BOX.w, NAME_BOX.h);
  ctx.strokeStyle = nameEditing ? '#5ca0f0' : '#444';
  ctx.lineWidth = nameEditing ? 2 : 1;
  ctx.strokeRect(NAME_BOX.x, NAME_BOX.y, NAME_BOX.w, NAME_BOX.h);
  ctx.font = 'bold 18px sans-serif'; ctx.fillStyle = '#fff';
  const displayName = myName || (nameEditing ? '' : 'Click to set name');
  if (!myName && !nameEditing) { ctx.fillStyle = '#555'; ctx.font = '14px sans-serif'; }
  ctx.fillText(displayName + (nameEditing ? '_' : ''), FCX, NAME_BOX.y + NAME_BOX.h / 2);

  const bx = FCX - BTN_W / 2;
  for (const b of menuBtns) drawBtn(bx, b.y, BTN_W, BTN_H, b.label);

  // Fullscreen button (bottom) — iOS has no fullscreen API
  const isFS = document.fullscreenElement || document.webkitFullscreenElement;
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
  const isStandalone = window.navigator.standalone || window.matchMedia('(display-mode: standalone)').matches;
  if (isIOS && !isStandalone) {
    ctx.font = '12px sans-serif'; ctx.fillStyle = '#555'; ctx.textAlign = 'center';
    ctx.fillText('For fullscreen: Share \u2192 Add to Home Screen', FCX, 545);
  } else if (!isStandalone) {
    drawBtn(FCX - 80, 530, 160, 40, isFS ? 'EXIT FULLSCREEN' : 'FULLSCREEN', '#444');
  }

  if (showCodeInput) {
    ctx.fillStyle = 'rgba(0,0,0,0.75)'; ctx.fillRect(0, 0, W, H);
    ctx.font = 'bold 24px sans-serif'; ctx.fillStyle = '#fff';
    ctx.textAlign = 'center'; ctx.fillText('ENTER ROOM CODE', FCX, 240);
    const bw = 200, bh = 60;
    ctx.fillStyle = '#1a1a2e'; ctx.fillRect(FCX - bw / 2, 270, bw, bh);
    ctx.strokeStyle = '#2a80ff'; ctx.lineWidth = 2; ctx.strokeRect(FCX - bw / 2, 270, bw, bh);
    ctx.font = 'bold 36px monospace'; ctx.fillStyle = '#fff';
    ctx.fillText(codeInput + (codeInput.length < 4 ? '_' : ''), FCX, 300);
    ctx.font = '14px sans-serif'; ctx.fillStyle = '#888';
    ctx.fillText('Type 4 letters, then press Enter', FCX, 355);
    drawBtn(FCX - 60, 380, 120, 40, 'CANCEL', '#666');
  }
}

// ===== UI: Waiting/Lobby Screen =====
function drawWaitingScreen() {
  ctx.fillStyle = '#0f0f1a'; ctx.fillRect(0, 0, W, H);
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

  if (roomMode !== 'quick') {
    ctx.font = '16px sans-serif'; ctx.fillStyle = '#888'; ctx.fillText('ROOM CODE', FCX, 80);
    ctx.font = 'bold 48px monospace'; ctx.fillStyle = '#2a80ff'; ctx.fillText(roomCode, FCX, 130);
  } else {
    ctx.font = 'bold 24px sans-serif'; ctx.fillStyle = '#fff'; ctx.fillText('QUICK PLAY', FCX, 100);
  }

  // Player slots
  const slotW = 160, slotH = 80, slotGap = 20;
  const totalW = slotW * 4 + slotGap * 3;
  const startX = FCX - totalW / 2;
  const slotY = 200;

  for (let i = 0; i < 4; i++) {
    const x = startX + i * (slotW + slotGap);
    const team = SLOT_TEAMS[i];
    const occ = slots[i] !== null;
    const me = ws && slots[i] === ws.id;
    ctx.fillStyle = occ ? (team === 0 ? 'rgba(42,128,255,0.2)' : 'rgba(224,69,69,0.2)') : 'rgba(255,255,255,0.05)';
    ctx.fillRect(x, slotY, slotW, slotH);
    ctx.strokeStyle = me ? '#fff' : (occ ? TEAMS[team].color : '#333');
    ctx.lineWidth = me ? 3 : 1; ctx.strokeRect(x, slotY, slotW, slotH);
    ctx.beginPath(); ctx.arc(x + slotW / 2, slotY + 30, 15, 0, Math.PI * 2);
    ctx.fillStyle = occ ? COLORS[i] : '#333'; ctx.fill();
    ctx.font = 'bold 12px sans-serif'; ctx.fillStyle = '#fff';
    ctx.fillText(String(i + 1), x + slotW / 2, slotY + 31);
    ctx.font = '12px sans-serif'; ctx.fillStyle = occ ? '#fff' : '#555';
    const slotName = occ ? (playerNames[i] || (me ? 'YOU' : 'PLAYER')) : 'EMPTY';
    ctx.fillText(slotName, x + slotW / 2, slotY + 62);
  }

  const count = slots.filter(s => s !== null).length;
  ctx.font = '18px sans-serif'; ctx.fillStyle = '#aaa';
  ctx.fillText(statusMsg || `Waiting for players... (${count}/4)`, FCX, 340);

  const canStart = roomMode !== 'quick' && count >= 2;
  if (canStart) drawBtn(FCX - 130, 400, 120, 45, 'START', '#2d8a4e');
  drawBtn(FCX + (canStart ? 10 : -60), 400, 120, 45, 'LEAVE', '#666');

  const myId = ws ? ws.id.slice(0, 8) : '-';
  ctx.font = '12px sans-serif'; ctx.fillStyle = '#555';
  ctx.fillText(`ID: ${myId}`, FCX, 480);
}

// ===== UI: Game Over Overlay =====
function drawGameOverOverlay() {
  ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(0, 0, W, H);
  if (!winner) return;
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.font = 'bold 64px sans-serif'; ctx.fillStyle = winner.color;
  ctx.fillText(winner.name + ' WINS!', FCX, FCY - 60);
  ctx.font = 'bold 28px sans-serif'; ctx.fillStyle = '#fff';
  ctx.fillText(`${teamScores[0]} - ${teamScores[1]}`, FCX, FCY);

  if (roomMode === 'quick') {
    const secs = Math.ceil(Math.max(autoRematchTimer, 0));
    ctx.font = 'bold 22px sans-serif'; ctx.fillStyle = '#aaa';
    ctx.fillText(`Next round in ${secs}...`, FCX, FCY + 50);
    drawBtn(FCX - 60, FCY + 80, 120, 45, 'LEAVE', '#666');
  } else {
    const total = slots.filter(s => s !== null).length;
    const voted = myRematchVoted;
    drawBtn(FCX - 130, FCY + 40, 120, 45, voted ? `VOTED ${rematchVoteCount}/${total}` : 'REMATCH', voted ? '#555' : '#2d8a4e');
    drawBtn(FCX + 10, FCY + 40, 120, 45, 'LEAVE', '#666');
  }
}

// ===== Rendering: Field =====
function drawField() {
  ctx.fillStyle = '#2d8a4e'; ctx.fillRect(FL, FT, FW, FH);
  for (let i = 0; i < FW; i += 60) {
    if ((i / 60) % 2 === 0) { ctx.fillStyle = 'rgba(0,0,0,0.04)'; ctx.fillRect(FL + i, FT, 60, FH); }
  }
}

function drawGoalNets() {
  ctx.fillStyle = 'rgba(42,128,255,0.10)'; ctx.fillRect(FL - GD, GT, GD, GH);
  ctx.fillStyle = 'rgba(224,69,69,0.10)'; ctx.fillRect(FR, GT, GD, GH);
  ctx.save();
  ctx.beginPath(); ctx.rect(FL - GD, GT, GD, GH); ctx.clip();
  ctx.strokeStyle = 'rgba(255,255,255,0.12)'; ctx.lineWidth = 0.5; ctx.beginPath();
  for (let i = -GH; i < GD + GH; i += 12) {
    ctx.moveTo(FL - GD + i, GT); ctx.lineTo(FL - GD + i + GH, GB);
    ctx.moveTo(FL - GD + i, GB); ctx.lineTo(FL - GD + i + GH, GT);
  }
  ctx.stroke(); ctx.restore();
  ctx.save();
  ctx.beginPath(); ctx.rect(FR, GT, GD, GH); ctx.clip();
  ctx.strokeStyle = 'rgba(255,255,255,0.12)'; ctx.lineWidth = 0.5; ctx.beginPath();
  for (let i = -GH; i < GD + GH; i += 12) {
    ctx.moveTo(FR + i, GT); ctx.lineTo(FR + i + GH, GB);
    ctx.moveTo(FR + i, GB); ctx.lineTo(FR + i + GH, GT);
  }
  ctx.stroke(); ctx.restore();
  ctx.strokeStyle = 'rgba(255,255,255,0.35)'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(FL, GT); ctx.lineTo(FL - GD, GT); ctx.lineTo(FL - GD, GB); ctx.lineTo(FL, GB); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(FR, GT); ctx.lineTo(FR + GD, GT); ctx.lineTo(FR + GD, GB); ctx.lineTo(FR, GB); ctx.stroke();
}

function drawMarkings() {
  ctx.strokeStyle = 'rgba(255,255,255,0.45)'; ctx.lineWidth = 2;
  ctx.strokeRect(FL, FT, FW, FH);
  ctx.beginPath(); ctx.moveTo(FCX, FT); ctx.lineTo(FCX, FB); ctx.stroke();
  ctx.beginPath(); ctx.arc(FCX, FCY, 55, 0, Math.PI * 2); ctx.stroke();
  ctx.beginPath(); ctx.arc(FCX, FCY, 4, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255,255,255,0.45)'; ctx.fill();
  const paW = 80, paH = 220;
  ctx.strokeRect(FL, FCY - paH / 2, paW, paH);
  ctx.strokeRect(FR - paW, FCY - paH / 2, paW, paH);
}

function drawGoalPosts() {
  for (const p of goalPosts) {
    ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
    ctx.fillStyle = '#fff'; ctx.fill();
    ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1; ctx.stroke();
  }
}

function drawFootball() {
  const bx = fb.x + ballSmoothX;
  const by = fb.y + ballSmoothY;
  ctx.beginPath(); ctx.arc(bx + 2, by + 2, fb.r, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fill();
  ctx.beginPath(); ctx.arc(bx, by, fb.r, 0, Math.PI * 2);
  ctx.fillStyle = '#f5f5f5'; ctx.fill();
  ctx.strokeStyle = '#888'; ctx.lineWidth = 1.5; ctx.stroke();
  ctx.beginPath();
  for (let i = 0; i < 5; i++) {
    const a = (i / 5) * Math.PI * 2 - Math.PI / 2;
    const px = bx + Math.cos(a) * fb.r * 0.45, py = by + Math.sin(a) * fb.r * 0.45;
    i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
  }
  ctx.closePath(); ctx.fillStyle = '#888'; ctx.fill();
  if (lastToucher) {
    ctx.beginPath(); ctx.arc(bx, by, fb.r + 4, 0, Math.PI * 2);
    ctx.strokeStyle = lastToucher.color; ctx.lineWidth = 2; ctx.globalAlpha = 0.6; ctx.stroke(); ctx.globalAlpha = 1;
  }
}

function aimLineEnd(px, py, angle) {
  const dx = Math.cos(angle), dy = Math.sin(angle);
  let tMin = Infinity;
  if (dx > 0) {
    let t = (FR - px) / dx;
    const hy = py + dy * t;
    if (hy >= GT && hy <= GB) t = (FR + GD - px) / dx;
    tMin = Math.min(tMin, t);
  }
  if (dx < 0) {
    let t = (FL - px) / dx;
    const hy = py + dy * t;
    if (hy >= GT && hy <= GB) t = (FL - GD - px) / dx;
    tMin = Math.min(tMin, t);
  }
  if (dy > 0) tMin = Math.min(tMin, (FB - py) / dy);
  if (dy < 0) tMin = Math.min(tMin, (FT - py) / dy);
  if (tMin <= 0 || tMin === Infinity) return null;
  return { x: px + dx * tMin, y: py + dy * tMin };
}

function drawPlayer(p) {
  let dx = 0, dy = 0;
  if (p.idx === mySlot) { dx = smoothX; dy = smoothY; }
  const px = p.x + dx, py = p.y + dy;
  const dim = !p.occupied;
  if (dim) ctx.globalAlpha = 0.35;

  ctx.beginPath(); ctx.arc(px + 2, py + 2, p.r, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(0,0,0,0.25)'; ctx.fill();
  ctx.beginPath(); ctx.arc(px, py, p.r, 0, Math.PI * 2);
  ctx.fillStyle = p.color; ctx.fill();
  ctx.strokeStyle = 'rgba(0,0,0,0.25)'; ctx.lineWidth = 2; ctx.stroke();
  ctx.beginPath(); ctx.arc(px - p.r * 0.25, py - p.r * 0.25, p.r * 0.35, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255,255,255,0.25)'; ctx.fill();
  ctx.fillStyle = '#fff'; ctx.font = 'bold 15px sans-serif';
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText(p.label, px, py + 1);

  const len = p.state === ST_AIM ? 25 + (p.power / MAX_POW) * 45 : 25;
  const ax = Math.cos(p.angle), ay = Math.sin(p.angle);
  const asx = px + ax * (p.r + 4), asy = py + ay * (p.r + 4);
  const aex = px + ax * (p.r + 4 + len), aey = py + ay * (p.r + 4 + len);
  ctx.beginPath(); ctx.moveTo(asx, asy); ctx.lineTo(aex, aey);
  ctx.strokeStyle = p.state === ST_AIM ? p.light : 'rgba(255,255,255,0.6)';
  ctx.lineWidth = p.state === ST_AIM ? 3.5 : 2; ctx.stroke();
  const hl = 10, ha = 0.45;
  ctx.beginPath();
  ctx.moveTo(aex, aey);
  ctx.lineTo(aex - hl * Math.cos(p.angle - ha), aey - hl * Math.sin(p.angle - ha));
  ctx.moveTo(aex, aey);
  ctx.lineTo(aex - hl * Math.cos(p.angle + ha), aey - hl * Math.sin(p.angle + ha));
  ctx.stroke();
  // Dotted aimline to field border
  if (showAimLine && p.occupied && p.state === ST_AIM) {
    const end = aimLineEnd(px, py, p.angle);
    if (end) {
      ctx.save();
      ctx.setLineDash([6, 6]);
      ctx.beginPath(); ctx.moveTo(aex, aey); ctx.lineTo(end.x, end.y);
      ctx.strokeStyle = p.light || 'rgba(255,255,255,0.4)';
      ctx.globalAlpha = 0.35; ctx.lineWidth = 1.5; ctx.stroke();
      ctx.restore();
    }
  }
  if (p.state === ST_AIM) {
    const pct = p.power / MAX_POW;
    ctx.beginPath(); ctx.arc(px, py, p.r + 7, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * pct);
    ctx.strokeStyle = p.light; ctx.lineWidth = 3; ctx.stroke();
  }

  if (gameState === 'PLAYING' && p.occupied) {
    const name = playerNames[p.idx];
    if (name) {
      ctx.font = 'bold 11px sans-serif'; ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.fillText(name, px, py - p.r - 12);
    }
  }
  if (dim) ctx.globalAlpha = 1;
}

function drawScoreboard() {
  ctx.textBaseline = 'middle';
  const y = 26;
  ctx.beginPath(); ctx.arc(W / 2 - 120, y, 10, 0, Math.PI * 2);
  ctx.fillStyle = TEAMS[0].color; ctx.fill();
  ctx.font = 'bold 16px monospace'; ctx.fillStyle = '#ccc'; ctx.textAlign = 'right';
  ctx.fillText('BLUE', W / 2 - 135, y);
  ctx.font = 'bold 28px monospace'; ctx.fillStyle = '#fff'; ctx.textAlign = 'center';
  ctx.fillText(teamScores[0], W / 2 - 100, y);
  ctx.font = 'bold 22px monospace'; ctx.fillStyle = '#666'; ctx.fillText('-', W / 2, y);
  ctx.beginPath(); ctx.arc(W / 2 + 120, y, 10, 0, Math.PI * 2);
  ctx.fillStyle = TEAMS[1].color; ctx.fill();
  ctx.font = 'bold 16px monospace'; ctx.fillStyle = '#ccc'; ctx.textAlign = 'left';
  ctx.fillText('RED', W / 2 + 135, y);
  ctx.font = 'bold 28px monospace'; ctx.fillStyle = '#fff'; ctx.textAlign = 'center';
  ctx.fillText(teamScores[1], W / 2 + 100, y);
  ctx.font = '13px monospace'; ctx.fillStyle = 'rgba(255,255,255,0.35)'; ctx.textAlign = 'center';
  const hint = myShootMode === 0
    ? 'Hold to aim & charge, release to shoot'
    : 'Click field to aim, hold to charge, release to shoot';
  ctx.fillText(hint + '  |  First to ' + WIN_SCORE, W / 2, H - 16);
  // Debug overlay
  ctx.font = '11px monospace'; ctx.fillStyle = '#ff0'; ctx.textAlign = 'left';
  ctx.fillText(`slot=${mySlot} id=${ws ? ws.id.slice(0,6) : '-'}`, 8, H - 4);
}

function drawModeButtons() {
  if (gameState !== 'PLAYING') return;
  for (let i = 0; i < 2; i++) {
    const x = MODE_BTN.x + i * (MODE_BTN.w + MODE_BTN.gap);
    const active = myShootMode === i;
    ctx.fillStyle = active ? '#2a80ff' : 'rgba(255,255,255,0.1)';
    ctx.fillRect(x, MODE_BTN.y, MODE_BTN.w, MODE_BTN.h);
    ctx.strokeStyle = active ? '#5ca0f0' : '#555';
    ctx.lineWidth = 1;
    ctx.strokeRect(x, MODE_BTN.y, MODE_BTN.w, MODE_BTN.h);
    ctx.fillStyle = active ? '#fff' : '#888';
    ctx.font = 'bold 14px sans-serif';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(String(i + 1), x + MODE_BTN.w / 2, MODE_BTN.y + MODE_BTN.h / 2);
  }
}

function drawTuningPanel() {
  // Toggle button (top-right)
  ctx.fillStyle = tuningOpen ? '#2a80ff' : 'rgba(255,255,255,0.1)';
  ctx.fillRect(TUNE_BTN.x, TUNE_BTN.y, TUNE_BTN.w, TUNE_BTN.h);
  ctx.strokeStyle = tuningOpen ? '#5ca0f0' : '#555';
  ctx.lineWidth = 1;
  ctx.strokeRect(TUNE_BTN.x, TUNE_BTN.y, TUNE_BTN.w, TUNE_BTN.h);
  ctx.fillStyle = tuningOpen ? '#fff' : '#888';
  ctx.font = '16px sans-serif';
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText('\u2699', TUNE_BTN.x + TUNE_BTN.w / 2, TUNE_BTN.y + TUNE_BTN.h / 2);
  if (!tuningOpen) return;
  const { x, y, w, rowH, pad } = TUNE_PANEL;
  const totalRows = TUNABLES.length + 1; // +1 for aim line toggle
  const h = pad * 2 + totalRows * rowH;
  ctx.fillStyle = 'rgba(0,0,0,0.85)';
  ctx.fillRect(x, y, w, h);
  ctx.strokeStyle = '#555'; ctx.lineWidth = 1;
  ctx.strokeRect(x, y, w, h);
  const bw = 24, bh = 20;
  for (let i = 0; i < TUNABLES.length; i++) {
    const t = TUNABLES[i];
    const ry = y + pad + i * rowH;
    ctx.font = '12px sans-serif'; ctx.fillStyle = '#aaa'; ctx.textAlign = 'left';
    ctx.fillText(t.label, x + 8, ry + rowH / 2);
    ctx.font = 'bold 13px monospace'; ctx.fillStyle = '#fff'; ctx.textAlign = 'center';
    ctx.fillText(getParam(t.key).toFixed(t.dp), x + w / 2 + 10, ry + rowH / 2);
    const minusX = x + w - 60, plusX = x + w - 32, btnY = ry + (rowH - bh) / 2;
    ctx.fillStyle = '#c43030'; ctx.fillRect(minusX, btnY, bw, bh);
    ctx.fillStyle = '#fff'; ctx.font = 'bold 16px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('\u2212', minusX + bw / 2, ry + rowH / 2);
    ctx.fillStyle = '#2d8a4e'; ctx.fillRect(plusX, btnY, bw, bh);
    ctx.fillStyle = '#fff';
    ctx.fillText('+', plusX + bw / 2, ry + rowH / 2);
  }
  // Aim Line toggle row
  const ary = y + pad + TUNABLES.length * rowH;
  ctx.font = '12px sans-serif'; ctx.fillStyle = '#aaa'; ctx.textAlign = 'left';
  ctx.fillText('Aim Line', x + 8, ary + rowH / 2);
  const tbw = 52, tbh = 20, tbx = x + w - tbw - 8, tby = ary + (rowH - tbh) / 2;
  ctx.fillStyle = showAimLine ? '#2a80ff' : '#444';
  ctx.fillRect(tbx, tby, tbw, tbh);
  ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText(showAimLine ? 'ON' : 'OFF', tbx + tbw / 2, ary + rowH / 2);
}

function handleTuningClick(pos) {
  if (inRect(pos, TUNE_BTN.x, TUNE_BTN.y, TUNE_BTN.w, TUNE_BTN.h)) {
    tuningOpen = !tuningOpen; return true;
  }
  if (!tuningOpen) return false;
  const { x, y, w, rowH, pad } = TUNE_PANEL;
  const totalRows = TUNABLES.length + 1;
  const h = pad * 2 + totalRows * rowH;
  if (inRect(pos, x, y, w, h)) {
    const bw = 24, bh = 20;
    for (let i = 0; i < TUNABLES.length; i++) {
      const t = TUNABLES[i];
      const ry = y + pad + i * rowH;
      const minusX = x + w - 60, plusX = x + w - 32, btnY = ry + (rowH - bh) / 2;
      if (inRect(pos, minusX, btnY, bw, bh)) {
        setParam(t.key, Math.max(t.min, +(getParam(t.key) - t.step).toFixed(t.dp)));
        sendParams(); return true;
      }
      if (inRect(pos, plusX, btnY, bw, bh)) {
        setParam(t.key, Math.min(t.max, +(getParam(t.key) + t.step).toFixed(t.dp)));
        sendParams(); return true;
      }
    }
    // Aim Line toggle
    const ary = y + pad + TUNABLES.length * rowH;
    const tbw = 52, tbh = 20, tbx = x + w - tbw - 8, tby = ary + (rowH - tbh) / 2;
    if (inRect(pos, tbx, tby, tbw, tbh)) { showAimLine = !showAimLine; return true; }
    return true; // consumed by panel area
  }
  return false;
}

function drawGoalCelebration() {
  ctx.fillStyle = 'rgba(0,0,0,0.45)'; ctx.fillRect(0, 0, W, H);
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.font = 'bold 72px sans-serif'; ctx.fillStyle = goalScoredBy.color;
  ctx.fillText('GOAL!', FCX, FCY - 25);
  ctx.font = 'bold 28px sans-serif'; ctx.fillStyle = '#fff';
  const scorerText = goalScoredBy.scorer
    ? goalScoredBy.scorer + ' scores for ' + goalScoredBy.name + '!'
    : goalScoredBy.name + ' scores!';
  ctx.fillText(scorerText, FCX, FCY + 30);
}

// ===== State Unpack =====
function unpackState(buf) {
  // buf is a plain array from server JSON

  // Store for interpolation of remote entities
  interpFrom = interpTo;
  interpTo = new Float32Array(buf);
  interpStart = performance.now();

  // Own player: snap with smoothing offset
  if (mySlot >= 0 && mySlot < 4) {
    const p = players[mySlot], o = mySlot * 7;
    smoothX += p.x - buf[o];
    smoothY += p.y - buf[o+1];
    p.x = buf[o]; p.y = buf[o+1]; p.vx = buf[o+2]; p.vy = buf[o+3];
    // Click-aim mode: client is authoritative for angle;
    // during active aim OR brief post-shoot grace, also for state/power
    if (myShootMode === 1) {
      const inGrace = aimPos || (performance.now() - mode2ShootTime < MODE2_SHOOT_GRACE);
      if (!inGrace) { p.power = buf[o+5]; p.state = buf[o+6]; }
    } else {
      p.angle = buf[o+4]; p.power = buf[o+5]; p.state = buf[o+6];
    }
  }

  // Ball: snap with smoothing offset (local prediction corrected by server)
  ballSmoothX += fb.x - buf[28];
  ballSmoothY += fb.y - buf[29];
  fb.x = buf[28]; fb.y = buf[29]; fb.vx = buf[30]; fb.vy = buf[31];

  // Non-positional data: apply immediately
  const ltIdx = buf[32];
  lastToucher = ltIdx >= 0 ? players[ltIdx] : null;
  teamScores[0] = buf[33]; teamScores[1] = buf[34];
  const gsTeam = buf[35];
  if (gsTeam >= 0) {
    const scorerIdx = buf[32];
    const scorer = scorerIdx >= 0 ? (playerNames[scorerIdx] || '') : '';
    goalScoredBy = { team: gsTeam, color: TEAMS[gsTeam].color,
                     name: TEAMS[gsTeam].name, scorer };
    goalTimer = buf[36];
  } else {
    goalScoredBy = null;
    goalTimer = 0;
  }
}

// Interpolate remote entities between the last two host snapshots
function applyInterpolation() {
  if (!interpTo) return;
  const t = interpFrom
    ? Math.min((performance.now() - interpStart) / INTERP_MS, 1)
    : 1;

  for (let i = 0; i < 4; i++) {
    if (i === mySlot) continue; // own player handled by prediction
    const o = i * 7;
    if (interpFrom && t < 1) {
      players[i].x = interpFrom[o]   + (interpTo[o]   - interpFrom[o])   * t;
      players[i].y = interpFrom[o+1] + (interpTo[o+1] - interpFrom[o+1]) * t;
      // Angle: shortest-path interpolation
      let da = interpTo[o+4] - interpFrom[o+4];
      if (da > Math.PI) da -= Math.PI * 2;
      if (da < -Math.PI) da += Math.PI * 2;
      players[i].angle = interpFrom[o+4] + da * t;
      players[i].power = interpFrom[o+5] + (interpTo[o+5] - interpFrom[o+5]) * t;
    } else {
      players[i].x     = interpTo[o];
      players[i].y     = interpTo[o+1];
      players[i].angle = interpTo[o+4];
      players[i].power = interpTo[o+5];
    }
    players[i].vx    = interpTo[o+2];
    players[i].vy    = interpTo[o+3];
    players[i].state = interpTo[o+6];
  }

  // Ball: handled by local prediction + smoothing in unpackState/fixedUpdate
  // (not interpolated — allows instant collision response)
}

// ===== Networking =====
function generateCode() {
  const c = 'ABCDEFGHJKLMNPQRSTUVWXYZ';
  let code = '';
  for (let i = 0; i < 4; i++) code += c[Math.floor(Math.random() * c.length)];
  return code;
}

function joinNetRoom(roomId) {
  ws = new PartySocket({ host: PARTYKIT_HOST, room: roomId });
  mySlot = -1;
  slots = [null, null, null, null];
  statusMsg = 'Connecting...';

  ws.onmessage = (e) => {
    const msg = JSON.parse(e.data);
    switch (msg.type) {
      case 'assign':
        mySlot = msg.slot;
        slots = msg.slots;
        if (msg.names) playerNames = msg.names;
        playerNames[mySlot] = myName;
        statusMsg = '';
        // Reset smoothing for mid-game transitions
        if (gameState === 'PLAYING' || gameState === 'GAME_OVER') {
          smoothX = 0; smoothY = 0; ballSmoothX = 0; ballSmoothY = 0;
          pendingState = null; interpFrom = null; interpTo = null;
        }
        ws.send(JSON.stringify({ type: 'name', name: myName }));
        break;
      case 'state':
        if (gameState === 'PLAYING') pendingState = msg.data;
        break;
      case 'lobby':
        slots = msg.slots;
        if (msg.names) playerNames = msg.names;
        // Update occupied flags if game running
        if (gameState === 'PLAYING' || gameState === 'GAME_OVER') {
          for (let i = 0; i < 4; i++) {
            if (players[i]) players[i].occupied = slots[i] !== null;
          }
        }
        break;
      case 'start':
        slots = msg.slots;
        if (msg.names) playerNames = msg.names;
        if (msg.midGame) {
          initGame();
          gameState = msg.gameState || 'PLAYING';
          if (msg.scores) { teamScores[0] = msg.scores[0]; teamScores[1] = msg.scores[1]; }
          smoothX = 0; smoothY = 0; ballSmoothX = 0; ballSmoothY = 0;
          pendingState = null; interpFrom = null; interpTo = null;
          myRematchVoted = false;
          if (gameState === 'GAME_OVER') autoRematchTimer = AUTO_REMATCH_DELAY;
        } else {
          startGame();
        }
        break;
      case 'gameover': {
        const team = msg.winner.team;
        winner = { team, color: TEAMS[team].color, name: TEAMS[team].name, scorer: msg.winner.scorer || '' };
        if (msg.scores) { teamScores[0] = msg.scores[0]; teamScores[1] = msg.scores[1]; }
        gameState = 'GAME_OVER';
        myRematchVoted = false;
        rematchVoteCount = 0;
        if (roomMode === 'quick') autoRematchTimer = AUTO_REMATCH_DELAY;
        break;
      }
      case 'full':
        statusMsg = 'Room is full';
        setTimeout(leaveRoom, 2000);
        break;
      case 'countdown':
        autoRematchTimer = msg.secs;
        break;
      case 'rematch':
        rematchVoteCount = msg.votes;
        rematchVoteTotal = msg.total;
        break;
      case 'params':
        if (msg.MAX_POW !== undefined) MAX_POW = msg.MAX_POW;
        if (msg.POW_RATE !== undefined) POW_RATE = msg.POW_RATE;
        if (msg.FRIC !== undefined) FRIC = msg.FRIC;
        if (msg.ROT_SPD !== undefined) ROT_SPD = msg.ROT_SPD;
        if (msg.REST !== undefined) REST = msg.REST;
        if (msg.PR !== undefined) { PR = msg.PR; players.forEach(p => p.r = PR); }
        if (msg.BR !== undefined) { BR = msg.BR; if (fb) fb.r = BR; }
        break;
      case 'event':
        handleAnnouncerEvent(msg);
        break;
      case 'announce':
        if (msg.audio && msg.text) playAnnouncement(msg.audio, msg.text);
        break;
    }
  };

  ws.onclose = () => {
    if (gameState !== 'MENU') {
      statusMsg = 'Disconnected';
      leaveRoom();
    }
  };

  gameState = 'WAITING';
}

function startGame() {
  initGame();
  gameState = 'PLAYING';
  myRematchVoted = false;
  rematchVoteCount = 0;
  smoothX = 0; smoothY = 0; ballSmoothX = 0; ballSmoothY = 0;
  pendingState = null; interpFrom = null; interpTo = null;
}

function leaveRoom() {
  gameState = 'MENU'; // set before close to prevent onclose re-entry
  if (ws) { ws.close(); ws = null; }
  slots = [null, null, null, null];
  mySlot = -1;
  showCodeInput = false; codeInput = '';
  statusMsg = ''; roomCode = ''; roomMode = '';
  pendingState = null; interpFrom = null; interpTo = null;
  autoRematchTimer = 0;
  playerNames = ['', '', '', ''];
  myRematchVoted = false;
  rematchVoteCount = 0;
  rematchVoteTotal = 0;
}

// ===== Input =====
function handleInputDown() {
  if (gameState !== 'PLAYING' || goalScoredBy || winner || mySlot < 0) return;
  const p = players[mySlot];
  if (p && p.state !== ST_AIM) {
    p.state = ST_AIM; p.power = 0;
    if (ws) ws.send(JSON.stringify({ type: 'input', action: 'down' }));
  }
}

function handleInputUp() {
  if (gameState !== 'PLAYING' || goalScoredBy || winner || mySlot < 0) return;
  const p = players[mySlot];
  if (p && p.state === ST_AIM) {
    p.shoot();
    if (ws) ws.send(JSON.stringify({ type: 'input', action: 'up' }));
  }
}

// ===== Mode 2 (click-aim) Input =====
function handleMode2Down(pos) {
  if (goalScoredBy || winner || mySlot < 0) return;
  const p = players[mySlot];
  if (!p) return;
  aimPos = pos;
  p.angle = Math.atan2(pos.y - p.y, pos.x - p.x);
  p.state = ST_AIM; p.power = 0;
  if (ws) ws.send(JSON.stringify({ type: 'input', action: 'down', angle: p.angle }));
}

function handleMode2Move(pos) {
  if (mySlot < 0) return;
  const p = players[mySlot];
  if (!p || p.state !== ST_AIM) return;
  aimPos = pos;
  p.angle = Math.atan2(pos.y - p.y, pos.x - p.x);
  const now = performance.now();
  if (now - lastAimSend >= AIM_SEND_INTERVAL) {
    lastAimSend = now;
    if (ws) ws.send(JSON.stringify({ type: 'input', action: 'aim', angle: p.angle }));
  }
}

function handleMode2Up() {
  if (mySlot < 0) { aimPos = null; return; }
  const p = players[mySlot];
  if (!p || p.state !== ST_AIM) { aimPos = null; return; }
  if (ws) ws.send(JSON.stringify({ type: 'input', action: 'up', angle: p.angle }));
  p.shoot();
  aimPos = null;
  mode2ShootTime = performance.now();
}

// ===== Mode Toggle Buttons =====
function handleModeButtonClick(pos) {
  if (gameState !== 'PLAYING') return false;
  for (let i = 0; i < 2; i++) {
    const x = MODE_BTN.x + i * (MODE_BTN.w + MODE_BTN.gap);
    if (inRect(pos, x, MODE_BTN.y, MODE_BTN.w, MODE_BTN.h)) {
      myShootMode = i;
      aimPos = null;
      if (ws) ws.send(JSON.stringify({ type: 'mode', mode: i }));
      return true;
    }
  }
  return false;
}

function handleClick(pos) {
  if (gameState === 'MENU') {
    if (showCodeInput) {
      if (inRect(pos, FCX - 60, 380, 120, 40)) { showCodeInput = false; codeInput = ''; }
      return;
    }
    // Name input box click — signal caller to focus the hidden input
    if (inRect(pos, NAME_BOX.x, NAME_BOX.y, NAME_BOX.w, NAME_BOX.h)) {
      nameEditing = true;
      nameEl.value = myName;
      return 'focusName';
    }
    nameEditing = false;
    nameEl.blur();
    const bx = FCX - BTN_W / 2;
    for (const b of menuBtns) {
      if (inRect(pos, bx, b.y, BTN_W, BTN_H)) {
        if (!myName) myName = 'P' + String(Math.floor(Math.random() * 900) + 100);
        localStorage.setItem('faceballs-name', myName);
        if (b.action === 'quick') {
          roomCode = 'QUICK'; roomMode = 'quick';
          joinNetRoom('quickplay');
        } else if (b.action === 'create') {
          roomCode = generateCode(); roomMode = 'create';
          joinNetRoom(roomCode);
        } else if (b.action === 'join') {
          showCodeInput = true; codeInput = ''; roomMode = 'join';
        }
        return;
      }
    }
    // Fullscreen button
    if (inRect(pos, FCX - 80, 530, 160, 40)) { toggleFullscreen(); return; }
  } else if (gameState === 'WAITING') {
    const count = slots.filter(s => s !== null).length;
    const canStart = roomMode !== 'quick' && count >= 2;
    if (canStart && inRect(pos, FCX - 130, 400, 120, 45)) {
      if (ws) ws.send(JSON.stringify({ type: 'start' }));
      return;
    }
    const leaveBtnX = canStart ? FCX + 10 : FCX - 60;
    if (inRect(pos, leaveBtnX, 400, 120, 45)) { leaveRoom(); return; }
  } else if (gameState === 'GAME_OVER') {
    if (roomMode === 'quick') {
      if (inRect(pos, FCX - 60, FCY + 80, 120, 45)) { leaveRoom(); return; }
    } else {
      if (inRect(pos, FCX - 130, FCY + 40, 120, 45) && !myRematchVoted) {
        myRematchVoted = true;
        rematchVoteCount++;
        if (ws) ws.send(JSON.stringify({ type: 'rematch' }));
        return;
      }
      if (inRect(pos, FCX + 10, FCY + 40, 120, 45)) { leaveRoom(); return; }
    }
  }
}

// Keyboard
window.addEventListener('keydown', e => {
  if (nameEditing) {
    // Handled by hidden input element (nameEl)
    return;
  }
  if (showCodeInput) {
    if (e.key === 'Escape') { showCodeInput = false; return; }
    if (e.key === 'Backspace') { codeInput = codeInput.slice(0, -1); return; }
    if (e.key === 'Enter' && codeInput.length === 4) {
      roomCode = codeInput.toUpperCase();
      showCodeInput = false;
      if (!myName) { myName = 'P' + String(Math.floor(Math.random() * 900) + 100); localStorage.setItem('faceballs-name', myName); }
      joinNetRoom(roomCode);
      return;
    }
    if (codeInput.length < 4 && /^[a-zA-Z]$/.test(e.key)) codeInput += e.key.toUpperCase();
    return;
  }
  if (e.key === ' ' || e.code === 'Space') { e.preventDefault(); if (myShootMode === 0) handleInputDown(); }
});

window.addEventListener('keyup', e => {
  if (nameEditing || showCodeInput) return;
  if (e.key === ' ' || e.code === 'Space') { e.preventDefault(); if (myShootMode === 0) handleInputUp(); }
});

// Mouse — canvas handles UI clicks + game input
cvs.addEventListener('mousedown', e => {
  const pos = canvasPos(e);
  if (handleAnnouncerButtonClick(pos)) return;
  if (gameState === 'PLAYING' && handleTuningClick(pos)) return;
  if (gameState === 'PLAYING' && handleModeButtonClick(pos)) return;
  const result = handleClick(pos);
  if (result === 'focusName') setTimeout(() => nameEl.focus(), 0); // defer for desktop
  if (gameState === 'PLAYING') {
    if (myShootMode === 1) handleMode2Down(pos);
    else handleInputDown();
  }
});
cvs.addEventListener('mousemove', e => {
  if (gameState === 'PLAYING' && myShootMode === 1 && aimPos) handleMode2Move(canvasPos(e));
});
cvs.addEventListener('mouseup', () => {
  if (gameState === 'PLAYING') {
    if (myShootMode === 1 && aimPos) handleMode2Up();
    else handleInputUp();
  }
});

// Touch — canvas handles UI clicks + game input
cvs.addEventListener('touchstart', e => {
  e.preventDefault();
  const pos = canvasPos(e);
  if (handleAnnouncerButtonClick(pos)) return;
  if (gameState === 'PLAYING' && handleTuningClick(pos)) return;
  if (gameState === 'PLAYING' && handleModeButtonClick(pos)) return;
  const result = handleClick(pos);
  if (result === 'focusName') nameEl.focus(); // must be synchronous for mobile keyboard
  if (gameState === 'PLAYING') {
    if (myShootMode === 1) handleMode2Down(pos);
    else handleInputDown();
  }
}, { passive: false });
cvs.addEventListener('touchmove', e => {
  e.preventDefault();
  if (gameState === 'PLAYING' && myShootMode === 1 && aimPos) handleMode2Move(canvasPos(e));
}, { passive: false });
cvs.addEventListener('touchend', e => {
  e.preventDefault();
  if (gameState === 'PLAYING') {
    if (myShootMode === 1 && aimPos) handleMode2Up();
    else handleInputUp();
  }
}, { passive: false });

// Document-level — catch touches/clicks outside canvas (black area) for game input only
document.addEventListener('mousedown', e => {
  if (e.target === cvs) return; // already handled above
  if (gameState === 'PLAYING' && myShootMode === 0) handleInputDown();
});
document.addEventListener('mousemove', e => {
  if (gameState === 'PLAYING' && myShootMode === 1 && aimPos) handleMode2Move(canvasPos(e));
});
document.addEventListener('mouseup', e => {
  if (e.target === cvs) return;
  if (gameState === 'PLAYING') {
    if (myShootMode === 1 && aimPos) handleMode2Up();
    else handleInputUp();
  }
});
document.addEventListener('touchstart', e => {
  if (e.target === cvs) return;
  e.preventDefault();
  if (gameState === 'PLAYING' && myShootMode === 0) handleInputDown();
}, { passive: false });
document.addEventListener('touchend', e => {
  if (e.target === cvs) return;
  e.preventDefault();
  if (gameState === 'PLAYING') {
    if (myShootMode === 1 && aimPos) handleMode2Up();
    else handleInputUp();
  }
}, { passive: false });

// Fullscreen (with vendor prefixes for mobile)
function toggleFullscreen() {
  const el = document.documentElement;
  const isFS = document.fullscreenElement || document.webkitFullscreenElement;
  if (isFS) {
    (document.exitFullscreen || document.webkitExitFullscreen).call(document);
  } else {
    const req = el.requestFullscreen || el.webkitRequestFullscreen;
    if (req) req.call(el).catch(() => {});
  }
}

// ===== Fixed Update =====
const FDT = 1 / 60;
let acc = 0, lt = 0;

function fixedUpdate() {
  // Subtitle timer always ticks
  if (subtitleTimer > 0) { subtitleTimer -= FDT; if (subtitleTimer <= 0) { subtitleText = ''; subtitleTimer = 0; } }
  if (gameState !== 'PLAYING') return;
  if (goalScoredBy) return; // Server handles goal timer; client just freezes

  // Client prediction: own player + ball (others handled by interpolation)
  const me = (mySlot >= 0 && mySlot < 4) ? players[mySlot] : null;
  if (me && me.occupied) {
    if (myShootMode === 0 && me.state === ST_ROT) me.angle += ROT_SPD * FDT;
    if (me.state === ST_AIM) me.power = Math.min(me.power + POW_RATE * FDT, MAX_POW);
    me.x += me.vx; me.y += me.vy;
    me.vx *= FRIC; me.vy *= FRIC;
    if (Math.abs(me.vx) < MIN_V && Math.abs(me.vy) < MIN_V) { me.vx = 0; me.vy = 0; }
    wallBounce(me);
    postCol(me);
    for (let i = 0; i < 4; i++) {
      if (i === mySlot) continue;
      circleCol(me, players[i], PMASS, PMASS);
    }
  }
  // Local ball prediction (including remote player collisions)
  updateFb();
  wallBounce(fb);
  postCol(fb);
  if (me && circleCol(me, fb, PMASS, BMASS)) lastToucher = me;
  for (let i = 0; i < 4; i++) {
    if (i === mySlot) continue;
    if (players[i] && players[i].occupied && circleCol(players[i], fb, PMASS, BMASS))
      lastToucher = players[i];
  }
  // Decay prediction smoothing
  smoothX *= SMOOTH_DECAY;
  smoothY *= SMOOTH_DECAY;
  if (Math.abs(smoothX) < 0.1) smoothX = 0;
  if (Math.abs(smoothY) < 0.1) smoothY = 0;
  ballSmoothX *= BALL_SMOOTH_DECAY;
  ballSmoothY *= BALL_SMOOTH_DECAY;
  if (Math.abs(ballSmoothX) < 0.1) ballSmoothX = 0;
  if (Math.abs(ballSmoothY) < 0.1) ballSmoothY = 0;
}

// ===== Main Render =====
function renderGame() {
  ctx.fillStyle = '#0f0f1a'; ctx.fillRect(0, 0, W, H);
  drawGoalNets(); drawField(); drawMarkings(); drawGoalPosts();
  drawFootball();
  for (const p of players) drawPlayer(p);
  drawScoreboard();
  drawModeButtons();
  drawAnnouncerButton();
  drawTuningPanel();
  if (goalScoredBy && !winner) drawGoalCelebration();
  drawSubtitle();
}

function render() {
  if (gameState === 'MENU') drawMenuScreen();
  else if (gameState === 'WAITING') drawWaitingScreen();
  else if (gameState === 'PLAYING') renderGame();
  else if (gameState === 'GAME_OVER') { renderGame(); drawGameOverOverlay(); drawSubtitle(); }
}

// ===== Game Loop =====
function loop(time) {
  if (lt === 0) { lt = time; requestAnimationFrame(loop); return; }
  let dt = (time - lt) / 1000; lt = time;
  dt = Math.min(dt, 0.1);

  // Apply buffered network state once per frame (before physics)
  if (pendingState) {
    try { unpackState(pendingState); } catch (e) { console.warn('State unpack error:', e); }
    pendingState = null;
  }

  acc += dt;
  while (acc >= FDT) { fixedUpdate(); acc -= FDT; }

  // Interpolate remote entities for smooth rendering
  if (gameState === 'PLAYING') applyInterpolation();

  // Quickplay auto-rematch countdown (display only — server triggers the actual restart)
  if (gameState === 'GAME_OVER' && roomMode === 'quick') {
    autoRematchTimer -= dt;
    if (autoRematchTimer < 0) autoRematchTimer = 0;
  }

  render();
  requestAnimationFrame(loop);
}

// ===== Responsive Scaling =====
function resize() {
  const s = Math.min(innerWidth / W, innerHeight / H);
  cvs.style.width = W * s + 'px';
  cvs.style.height = H * s + 'px';
}
addEventListener('resize', resize);
resize();

initGame();
requestAnimationFrame(loop);
</script>
</body>
</html>
